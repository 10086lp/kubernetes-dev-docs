# Kubernetes 事件队列

Queue 接口是在 `Store` 的基础上，添加了 `Pop()` 方法。

FIFO 和 DeltaFIFO 类型(非接口)实现了 `Queue` 接口。

## Queue 是添加了 Pop 方法的 Store

Queue 接口是在 `Store` 的基础上，添加了 `Pop()` 方法：

``` go
// 来源于 k8s.io/client-go/tools/cache/fifo.go
type Queue interface {
    Store

    // Pop 方法返回处理后的对象，以及处理结果。如果 Queue 为空，该方法将一直阻塞。
    Pop(PopProcessFunc) (interface{}, error)

    AddIfNotPresent(interface{}) error

    // 当队列中第一批元素都 Pop 后，返回 true。
    HasSynced() bool
    Close()
}
```

导出函数 `Pop()` 从传入的 Queue 弹出一个对象。

## FIFO 实现了 Queue/Store 接口

FIFO 类型实现了 Queue/Store 接口（FIFO 是一个 struct 类型，而非接口），所以是一个先入先出(FIFO)的对象缓存。

对象被 Pop 的顺序与加入的顺序一致，所以是先入先出。但是位于 FIFO 中的某个对象在没有被 Pop 前，如果有多次对它的 `Add/Update()` 操作，FIFO 只会缓存它的最新值，而且该对象只会被 Pop 一次。

例如 FIFO 中对象 A 的值为 a1，在被 Pop 前，两次更新值分别为  a2, a3，则 Pop 只会返回最新值 a3。

所以，FIFO 只会缓存对象的**一个值，而且是最新值**。

FIFO 适合解决的问题：

1. 你希望最多一个 worker 处理某个对象( FIFO 只会缓存对象的一个值）；
2. 当 worker 处理该对象时，对象值是最新的；
3. 你不需要处理删除的对象(Pop 不会返回删除的对象)；

FIFO 类型定义如下：

``` go
// 来源于 k8s.io/client-go/tools/cache/fifo.go
type FIFO struct {
    lock sync.RWMutex
    cond sync.Cond

    // 对象缓存，用于快速查询。map key 为对象的 Key，该 Key 由 keyFunc 函数生成
    items map[string]interface{}

    // 对象弹出(Pop)顺序队列，队列中各对象 Key 是**唯一**的
    queue []string

    // 首先调用 Delete/Add/Update 或 Replace() 添加的第一批元素都 Pop 后为 true
    populated bool

    // Replace() 添加的第一批元素的数目
    initialPopulationCount int

    // 添加或减少 obj 用到的，生成 obj 标识 key 的函数
    keyFunc KeyFunc

    closed     bool
    closedLock sync.Mutex
}
```

函数 `NewFIFO()` 返回该类型对象，传入的 `KeyFunc` (一般是 `DeletionHandlingMetaNamespaceKeyFunc`) 用于生成对象 Key：

``` go
// 来源于 k8s.io/client-go/tools/cache/fifo.go
func NewFIFO(keyFunc KeyFunc) *FIFO {
    f := &FIFO{
        // 初始化对象缓存
        items:   map[string]interface{}{},
        // 初始化对象 Key 队列
        queue:   []string{},
        keyFunc: keyFunc,
    }
    f.cond.L = &f.lock
    return f
}
```

## `Add()` 方法

只有缓存中没有该对象时，才将它加入弹出(Pop)队列，这样可以保证该对象在未被 Pop 前只会由一个 worker 处理：

``` go
// 来源于 k8s.io/client-go/tools/cache/fifo.go
func (f *FIFO) Add(obj interface{}) error {
    id, err := f.keyFunc(obj)
    if err != nil {
        return KeyError{obj, err}
    }
    f.lock.Lock()
    defer f.lock.Unlock()
    f.populated = true

    // 缓存中没有该对象，则将它的 key 加到队列 f.queue 中
    if _, exists := f.items[id]; !exists {
        f.queue = append(f.queue, id)
    }
    // 更新对象缓存
    f.items[id] = obj
    f.cond.Broadcast()
    return nil
}
```

什么情况下缓存中没有该对象呢？

1. 第一次向 FIFO Add/Update 该对象；
2. 或者调用 FIFO 的 Delete 方法删除该对象；
3. 或者，该对象被 Pop 处理了；
4. 或者，调用 Replace 方法，用新的一组对象替换当前缓存 f.items 和队列 f.queue

## `Update()` 方法

是直接通过 `Add()` 方法实现的：

``` go
func (f *FIFO) Update(obj interface{}) error {
    return f.Add(obj)
}
```

## `Delete()` 方法

直接从缓存中删除对象：

``` go
// 来源于 k8s.io/client-go/tools/cache/fifo.go
func (f *FIFO) Delete(obj interface{}) error {
    id, err := f.keyFunc(obj)
    if err != nil {
        return KeyError{obj, err}
    }
    f.lock.Lock()
    defer f.lock.Unlock()
    f.populated = true
    // 从缓存中删除对象，注意 f.queue 中还可能有对象的 id
    delete(f.items, id)
    return err
}
```

由于**没有**从 Pop 队列(f.queue) 中移除该对象，如果先 Add/Update 对象，在 Pop 前又 Delete 该对象，则弹出队列中还有该对象的 Key 记录，Pop 遇到这种情况时**会跳过**，继续 Pop 下一个对象。所以 FIFO **不会缓存和 Pop 删除的对象**。

## `Pop()` 方法

返回弹出队列(f.queue) 中的对象，如果 f.queue 为空，则一直阻塞。

Pop 先从弹出队列(f.queue)移除对象，然后从对象缓存(f.items)中删除对象，接着调用 process 函数，如果该函数执行失败，则应该返回 `ErrRequeue` 类型的错误，这时该对象会被**重新加回** FIFO，后续可以再次被弹出处理。

`Pop()` 是在对 FIFO 加锁的情况下调用传入的 process 函数，所以可以在多个 goroutine 中**并发调用** `Pop()` 方法。

``` go
// 来源于 k8s.io/client-go/tools/cache/fifo.go
func (f *FIFO) Pop(process PopProcessFunc) (interface{}, error) {
    f.lock.Lock()
    defer f.lock.Unlock()
    for {
        for len(f.queue) == 0 {
            if f.IsClosed() {
                return nil, FIFOClosedError
            }
            // 如果队列未关闭，但为空，则阻塞等待
            f.cond.Wait()
        }
        // 先从 queue 弹出对象 id
        id := f.queue[0]
        f.queue = f.queue[1:]
        if f.initialPopulationCount > 0 {
            f.initialPopulationCount--
        }
        // 从缓存中获取对象
        item, ok := f.items[id]
        if !ok {
            // 前面提到，当 Add/Update 对象，在 Pop 前又 Delete 了该对象，就会出现 queue 中有 id，而 items 中无对象的情况
            // 由于对象已经被删除，所以跳过，Pop 下一个对象
            continue
        }
        // 从缓存中删除对象
        delete(f.items, id)
        // 调用处理函数，该函数处于 f.lock 锁保护中，可以并发执行
        err := process(item)
        // 如果处理 item 失败，应该返回 ErrRequeue 类型错误，再将对象加回队列
        if e, ok := err.(ErrRequeue); ok {
            f.addIfNotPresent(id, item)
            err = e.Err
        }
        return item, err
    }
}
```

## `Replace()` 方法

用传入的一组对象，替换 FIFO 的对象缓存 f.items 和弹出队列 f.queue（未弹出的对象被忽略）：

``` go
// 来源于 k8s.io/client-go/tools/cache/fifo.go
func (f *FIFO) Replace(list []interface{}, resourceVersion string) error {
    items := make(map[string]interface{}, len(list))
    for _, item := range list {
        key, err := f.keyFunc(item)
        if err != nil {
            return KeyError{item, err}
        }
        items[key] = item
    }

    f.lock.Lock()
    defer f.lock.Unlock()

    if !f.populated {
        f.populated = true
        f.initialPopulationCount = len(items)
    }

    f.items = items
    f.queue = f.queue[:0]
    for id := range items {
        f.queue = append(f.queue, id)
    }
    if len(f.queue) > 0 {
        f.cond.Broadcast()
    }
    return nil
}
```

## HasSyncd() 方法

参考后文对 `DeltaFIFO HasSyncd()` 方法的分析。

## `Resync()` 方法

将对象缓存 `f.items` 中的对象都更新到弹出队列 `f.queue` 中：

``` go
// 来源于 k8s.io/client-go/tools/cache/fifo.go
func (f *FIFO) Resync() error {
    f.lock.Lock()
    defer f.lock.Unlock()

    inQueue := sets.NewString()
    for _, id := range f.queue {
        inQueue.Insert(id)
    }
    for id := range f.items {
        if !inQueue.Has(id) {
            f.queue = append(f.queue, id)
        }
    }
    if len(f.queue) > 0 {
        f.cond.Broadcast()
    }
    return nil
}
```

**FIXME!!!**：对象加入和弹出时都会同时更新 f.items 和 f.queue，按说不会出现不一致的情况。所以 `Resync()` 方法是否是多余的？

## DeltaFIFO 是可以记录对象操作事件的 FIFO

`DeltaFIFO` 与 `FIFO` 类型的区别是：

1. FIFO 则内部维护了一个对象缓存(f.items)，而 DeltaFIFO 需要和一个外部维护的、包含所有对象的缓存(knownObjects) 结合使用：
    + Delete()：用 knownObjects 检查删除的对象是否存在，如果不存在则直接返回，否则生成 Deleted 事件； 
    + Replace()：确定为 knownObjects 中的哪些对象产生 Deleted 事件；
    + Resync()：将 knownObjects 中的对象同步到 DeltaFIFO 中，并生成 Sync 事件。
2. DeltaFIFO 缓存对象的事件列表，而 FIFO 缓存对象的最新值；
3. Delete/Replace/Resync() 方法不会从 DeltaFIFO 中删除/替换对象。DeltaFIFO 的消费者需要将他们从 knownObjects 删除（见后文）；
4. DeltaFIFO 的 Pop/Get() 方法，返回的不是对象最新值，而是 Deltas 类型的对象事件列表。

DeltaFIFO 可以解决的问题是：
1. 你希望最多一个 worker 处理某个对象的事件(与 FIFO 类似，对象在 Queue 中是唯一的)；
2. 当处理该对象时，可以获得自上次以来该对象的所有事件，如 Add/Updat/Delete（FIFO 只缓存和弹出该对象的最新值）；
3. 你可以处理删除对象的事件（FIFO 不支持该功能，它不会弹出被删除的对象）；
4. 你想周期处理所有的对象（调用 Resync 方法，将 knownObjects 中的对象同步到 DeltaFIFO 中）；

DeltaFIFO 是一个生产者-消费者队列，生产者是 [Reflector](3.reflector.md)，消费者主要是 [controller/sharedInformer/sharedIndexInformer](4.controller-informer.md)。

函数 `NewDeltaFIFO()` 返回一个 `DeltaFIFO` 类型对象：

``` go
// 来源于 k8s.io/client-go/tools/cache/delta_fifo.go
func NewDeltaFIFO(keyFunc KeyFunc, knownObjects KeyListerGetter) *DeltaFIFO {
    f := &DeltaFIFO{
        items:        map[string]Deltas{},
        queue:        []string{},
        keyFunc:      keyFunc,
        knownObjects: knownObjects,
    }
    f.cond.L = &f.lock
    return f
}
```

传入的 `knownObjects` 是实现了 `KeyListerGetter` 接口的 `Store` 或 `Index`（一般是 [cache](1.store-indexer-cache.md)），它缓存 DeltaFIFO 已知的所有对象。

DelaFIFO 只调用 `knownObjects` 缓存的两个**只读**方法，**不会对他进行更新**：
+ `f.knownObjects.GetByKey(id)`：按照 id 获取对象；
+ `f.knownObjects.ListKeys()`：列出所有对象的 Key；

各种 `Informer` 的创建函数，如 `NewInformer、NewIndexInformer、NewSharedInformer、NewSharedIndexInformer`，会依次创建 `knownObjects` 缓存(`struct cache` 类型)、`FIFO/DeltaFIO` 和 [`controller`](4.controller-informer.md)。

`controller` 使用 `DeltaFIFO` 作为队列，再将它传给创建的 [Reflector](3.reflector.md)，**Reflecter 是 FIFO/DeltaFIO 的生产者**。

**`controller` 是 `FIFO/DeltaFIFO` 的消费者，它同时负责更新 `knownObjects` 缓存**：
1. 从 FIFO 弹出对象;
2. 更新 knownObjects 缓存;
3. 再调用注册的 OnUpdate/OnAdd/OnDelete 回调函数；

所以，controller 用从 DetalFIFO 弹出的 Deltas 更新(取决于 Delta 中记录的事件类型) `knownObjects` 缓存，缓存的更新时间**晚于** FIFO。

各种 `Informer`、`controller` 使用 DeltaFIFO 的细节可以参考 [Reflector](3.reflector.md) 和 [`controller`](4.controller-informer.md) 文档。

## Add() 和 Update() 方法

    ``` go
    // 来源于 k8s.io/client-go/tools/cache/delta_fifo.go
    func (f *DeltaFIFO) Add(obj interface{}) error {
        f.lock.Lock()
        defer f.lock.Unlock()
        f.populated = true
        return f.queueActionLocked(Added, obj)
    }
    ```

`Update()` 方法和 `Add()` 方法类似，它最终调用 `f.queueActionLocked(Updated, obj)` 方法。

## queueActionLocked() 方法

queueActionLocked(actionType DeltaType, obj interface{})  ->

1. 如果事件类型为 Sync，而且 obj 对应的事件列表中最后一个事件为 Delete，则直接返回。
2. 合并 obj 连续重复的 Delete 事件为一个；
3. 如果 f.items[id] 中没有该元素，则将它的 id append 到 f.queue；     <-- 唯一更新 f.queue 的时机。
4. 将 obj 合并后的事件保存到 f.items[id]                            <-- 将 obj 当前事件与历史事件合并；

什么时候 `f.items[id]` 不存在呢？

1. DeltaFIFO 刚创建，元素第一次产生 Add/Update/Delete/Sync 事件；
2. 后续调用 f.Pop() 方法，弹出 id 对应的事件列表；

## Delete() 方法

Delete() 方法可能**直接返回**，也可能调用方法 `f.queueActionLocked(Deleted, obj)` 为对象生成 `Deleted` 事件。取决于 `f.knownObjects.GetByKey(id)` 和 `f.items[id]` 是否均均找不到对象。
    
注意：Delete() 方法**不将对象从事件缓存 f.items 和弹出队列 f.queue 删除**（FIFO 的 Deleta() 方法会将对象从缓存中删除），只是可能生成 Deleted 事件。DeltaFIFO 的消费者 `controller` 根据弹出的事件更新 f.knownObjects 缓存。

## Get/GetByKey/List/ListKeys() 方法

都是从内部缓存 f.items 中（非外部缓存 f.knownObjects）返回对象的 Deltas 或 Key 列表；

## Replace() 方法

Replace(list []interface{}, resourceVersion string)

1. 遍历 list 中的元素，为每个元素生成 Sync 事件，f.queueActionLocked(Sync, item)
2. 遍历 f.knownObjects.ListKeys() 中的元素，对于不在传入的 list 中的元素，生成 Delete 事件，添加的元素类型为 DeletedFinalStateUnknown（非 Delta 类型）：

    f.queueActionLocked(Deleted, DeletedFinalStateUnknown{k, deletedObj})

3. 如果 f.Replace() 方法是在创建 DeltaFIFO 后第一次调用的方法（Add/Update/Delete 之前，此时 f.populated 为 false），则设置：
    设置 f.populated 为 true；

    f.initialPopulationCount = len(list) + queuedDeletions，其中 queuedDeletions 为生成 DeletedFinalStateUnknown 的对象数目；

## Delta 和 DeletedFinalStateUnknown 事件

前面介绍过，**Reflecter 是 FIFO/DeltaFIO 的生产者**，**`controller` 是 `FIFO/DeltaFIFO` 的消费者，它同时负责更新 `knownObjects` 缓存**：

Reflecter 的 ListAndWatch() 方法负责更新内部的 DeltaFIO（具体参考：[3.reflector.md](3.reflector.md)）：

1. 从 kube-apiserver List 特定类型的所有对象，然后调用 DeltaFIFO 的 Replace() 方法；
2. 根据配置的 Resync 时间，周期调用 DeltaFIFO 的 Resync() 方法；
3. 后续的 Watch 阶段，会根据事件的类型，调用 DeltaFIFO 的 Add/Update/Delete 方法；

Reflecter 的 `Run()` 方法调用 `ListAndWatch()` 方法，如果没有出错则一直阻塞，当出错时，会等待 r.period 时间（**期间没有 Watch，可能会丢事件**），再次执行 ListAndWatch() 方法获取特定类型所有对象并 Watch。

``` go
func (r *Reflector) Run(stopCh <-chan struct{}) {
	klog.V(3).Infof("Starting reflector %v (%s) from %s", r.expectedType, r.resyncPeriod, r.name)
	wait.Until(func() {
		if err := r.ListAndWatch(stopCh); err != nil {
			utilruntime.HandleError(err)
		}
	}, r.period, stopCh)
}
```

所以，Reflecter 可能会**多次调用** DeltaFIFO 的 Replace() 方法。

有且只有 Replace() 方法可能生成 DeletedFinalStateUnknown 事件，如：

1. Reflecter 重新执行 ListAndWatch() 方法的 Sleep r.period 期间丢了该对象的 Delete 事件（所以对象还在 f.knownObjects 中）；
2. Reflecter 执行 ListAndWatch() 方法从 kube-apiserver LIST 该类型资源对象的结果中没有该对象；

``` go
type Delta struct {
	Type   DeltaType
	Object interface{}
}
type DeletedFinalStateUnknown struct {
	Key string
	Obj interface{}
}
```

+ Delta 代表正常的事件，包含事件类型和元素，Object 是事件产生后的状态；
+ DeletedFinalStateUnknown 代表删除事件，Key 为对象的 id；

## Resync() 方法

    遍历 f.knownObjects.ListKeys() 中的元素：
        对于某个元素 id，如果 f.items[id] 有值(长度 > 0)，则跳过；
        否则，生成 Sync 事件：f.queueActionLocked(Sync, obj)

综上，**Replace() 和 Rsync() 方法会会生成 Sync 事件**。

## Pop() 方法

Pop(process PopProcessFunc)

1. 如果 f.queue 为空，则阻塞等待；
2. 每次返回 f.queue 第 0 个对象 id 对应的 f.items[id]，即队列中该对象当前所有的操作事件列表 Deltas，然后将该对象从队列删除(f.items);
3. 返回的 Deltas 会传给 PopProcessFunc 执行，如果函数执行失败，应该再调用 AddIfNotPresent() 加会对象事件（Controler 里已实现）；

## HasSyncd() 方法

创建 FIFO/DealtaFIFO 后，如果首先调用的是 `Replace()` 方法，则 `f.populated` 被设置为 `true`， `f.initialPopulationCount` 被设置为传入的对象数量。当这一批对象都被弹出完毕时（ 包含弹出前被删除的对象），`HasSynced()` 方法返回 `true`：

``` go
// 来源于 k8s.io/client-go/tools/cache/fifo.go
func (f *DeltaFIFO) HasSynced() bool {
    f.lock.Lock()
    defer f.lock.Unlock()
    return f.populated && f.initialPopulationCount == 0
}
```

另外，如果在调用 `Replace()` 方法前，**首先**调用了 `Add/Update/Delete/AddIfNotPresent()` 方法，则 `HasSynced()` 方法也会返回 `true`。

后面会介绍，FIFO 的主要使用者是 `Refector`，它在启动后：

1. 首先从 kube-apiserver LIST 某类型对象，然后调用 FIFO 的 Replace() 方法，传入对象列表，实现将**某类型的所有对象**同步到缓存中；
2. 再从 kube-apiserver Watch 该类型对象的变化事件，如 Update/Delete，按需调用 FIFO 的 Add/Delete/Update 方法；
3. 周期从 kube-apiserver 中 Rsync 该类型的所有对象，传给 FIFO/DeltaFIFO 的 Replace() 方法；

所以，对于 `Refector` 的调用方而言，`HasSynce` 结果为 `true` 表示对象都已经**完整同步过一次和且被处理完毕**。