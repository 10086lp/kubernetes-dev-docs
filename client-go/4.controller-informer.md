# kubernetes 控制器和 SharedInformer

一般情况下， `Refector` 负责 DeltaFIFO 的 f.knownObjects (`clientState` 对象) 的更新，如先更新 f.knownObjects，再调用 DeltaFIFO 的 Add/Update/Delete/Rsync/Replace 的方法。

外部的 f.knownObjects 可能会出现**竞争情况**（race condition），如 DeltaFIFO 的消费者在处理 Pop 的对象 obj 时，f.knownObjects 中该对象发生了变化。Pop 方法会加锁，**所以是否出现竞争情况，取决于消费者是否在持有 DeltaFIFO 锁的同时更新 f.knownObjests**。

[sharedIndexInformer](https://github.com/kubernetes/kubernetes/blob/0cdd940f/staging/src/k8s.io/client-go/tools/cache/shared_informer.go#L192) 和 sharedInformer 都是在持有 DeltaFIFO 的锁的情况下，更新 knownObjects，所以**不会发生竞争情况**。

但是如果调用者修改 Infromer GetStore 和 GetIndexer 方法返回的缓存时，就**可能出现竞争**的情况。

一般的 controller 模式是使用一个 workqueue 来缓存对象的 Key，后续的 woker 线程通过对象 Key 从 Informer 返回的 Lister 中查询对象，所以**可能存在查找不到的情况**，这意味着该对象已经被删除。

controller 对于 CRD 对象的删除事件，一般是不需要处理的，因为删除意味着该对象已经不在 K8S 中了，但是如果需要清理该 CRD 创建的 K8S 资源对象，则可能需要捕获和处理删除事件。另外一种实现删除 CRD 对象的清理机制是为 CRD 指定 finalizer 列表。

对于 CRD 创建的类型对象，获取到后，需要看它是否是 CRD 创建的，如果不是则需要忽略。另外，对这些对象的删除事件，需要捕获，一般需要再次创建该对象。

controller 封装了 Reflector、DeletaFIFO 和 cache
sharedIndexInformer 封装了 controller

###

实例如下：

1. `controller` 将它的 c.config.Queue（一般是 DeltaFIFO） 传给 Reflector:

    ``` go
    // 来源于 k8s.io/client-go/tools/cache/controller.go
    func (c *controller) Run(stopCh <-chan struct{}) {
        defer utilruntime.HandleCrash()
        go func() {
            <-stopCh
            c.config.Queue.Close()
        }()
        r := NewReflector(
            c.config.ListerWatcher,
            c.config.ObjectType,
            c.config.Queue,
            c.config.FullResyncPeriod,
        )
        ...
    }
    ```

2. `NewInformer` 内部创建和运行 controller，它 ListWatch 特性的对象类型，当该类型的对象发生变化时，调用用户注册的函数。

    1. NewInformer 创建一个 struct cache 类型缓存(clientState)；
    2. 创建 DeltaFIFO ，使用 clientState 作为他的 knownObjects 缓存；
    3. 创建 controller，controller 创建 Reflect，给 Reflector 传入 DeltaFIFO，所以 **Reflect 是 DeltaFIFO 的生产者**；
    4. controller 用 FIFO 弹出的 Delta 对象更新(取决于 Delta 中记录的事件类型) `knownObjects` 缓存，再调用注册的 OnUpdate/OnAdd/OnDelete 回调函数；

    ``` go
	// 来源于 k8s.io/client-go/tools/cache/controller.go
	func NewInformer(
		lw ListerWatcher,
		objType runtime.Object,
		resyncPeriod time.Duration,
		h ResourceEventHandler,
	) (Store, Controller){
        // 创建一个 struct cache 类型缓存
        clientState := NewStore(DeletionHandlingMetaNamespaceKeyFunc)
        // 创建 DeltaFIFO ，使用 clientState 作为他的 knownObjects 缓存
		fifo := NewDeltaFIFO(MetaNamespaceKeyFunc, clientState)
        // controller 的配置
		cfg := &Config{
            // Queue 会传给 controller 创建的 Reflector
			Queue:            fifo,
			...
            Process: func(obj interface{}) error {
                // from oldest to newest
                // Deltas 是某个对象的事件列表
                for _, d := range obj.(Deltas) {
                    // 根据 Delta 中的事件类型，分别更新 clientState 和调用注册的处理函数
                    switch d.Type {
                    case Sync, Added, Updated:
                        if old, exists, err := clientState.Get(d.Object); err == nil && exists {
                            if err := clientState.Update(d.Object); err != nil {
                                return err
                            }
                            h.OnUpdate(old, d.Object)
                        } else {
                            if err := clientState.Add(d.Object); err != nil {
                                return err
                            }
                            h.OnAdd(d.Object)
                        }
                    case Deleted:
                        if err := clientState.Delete(d.Object); err != nil {
                            return err
                        }
                        h.OnDelete(d.Object)
                    }
                }
                return nil
            },
		}
		...
		return clientState, New(cfg)
	}
3. `NewIndexerInformer` 实现和 `NewInformer` 类似的逻辑：

    ``` go
    // 来源于 k8s.io/client-go/tools/cache/controller.go
	func NewIndexerInformer(
		lw ListerWatcher,
		objType runtime.Object,
		resyncPeriod time.Duration,
		h ResourceEventHandler,
		indexers Indexers,
	) (Indexer, Controller) {
		clientState := NewIndexer(DeletionHandlingMetaNamespaceKeyFunc, indexers)
		fifo := NewDeltaFIFO(MetaNamespaceKeyFunc, clientState)
		cfg := &Config{
			Queue:            fifo,
			...
            Process: func(obj interface{}) error {
                // from oldest to newest
                for _, d := range obj.(Deltas) {
                    switch d.Type {
                    case Sync, Added, Updated:
                        if old, exists, err := clientState.Get(d.Object); err == nil && exists {
                            if err := clientState.Update(d.Object); err != nil {
                                return err
                            }
                            h.OnUpdate(old, d.Object)
                        } else {
                            if err := clientState.Add(d.Object); err != nil {
                                return err
                            }
                            h.OnAdd(d.Object)
                        }
                    case Deleted:
                        if err := clientState.Delete(d.Object); err != nil {
                            return err
                        }
                        h.OnDelete(d.Object)
                    }
                }
                return nil
            },
		}
		...
		return clientState, New(cfg)
	}

    // 来源于 k8s.io/client-go/tools/cache/shared_informer.go
    func (s *sharedIndexInformer) Run(stopCh <-chan struct{}) {
        defer utilruntime.HandleCrash()

        fifo := NewDeltaFIFO(MetaNamespaceKeyFunc, s.indexer)
        cfg := &Config{
            Queue:            fifo,
            ...
        }
        ...
    }

    // 来源于 k8s.io/client-go/tools/cache/shared_informer.go
    func (s *sharedIndexInformer) HandleDeltas(obj interface{}) error {
        s.blockDeltas.Lock()
        defer s.blockDeltas.Unlock()

        // from oldest to newest
        for _, d := range obj.(Deltas) {
            switch d.Type {
            case Sync, Added, Updated:
                isSync := d.Type == Sync
                s.cacheMutationDetector.AddObject(d.Object)

                if old, exists, err := s.indexer.Get(d.Object); err == nil && exists {
                    if err := s.indexer.Update(d.Object); err != nil {
                        return err
                    }
                    s.processor.distribute(updateNotification{oldObj: old, newObj: d.Object}, isSync)
                } else {
                    if err := s.indexer.Add(d.Object); err != nil {
                        return err
                    }
                    s.processor.distribute(addNotification{newObj: d.Object}, isSync)
                }
            case Deleted:
                if err := s.indexer.Delete(d.Object); err != nil {
                    return err
                }
                s.processor.distribute(deleteNotification{oldObj: d.Object}, false)
            }
        }
        return nil
    }
    ```
上面的各种 Informer(NewInformer、NewIndexInformer、SharedInformer、SharedIndexInformer) 都是在 fifo Pop 对象的处理函数中更新  knownObjects 缓存，而 Pop 方法会对 DeltaFIFO 加锁，所以处理的过程中**不会发生竞争情况**，即处理的对象和缓存中的不一致。对于其他情况，可能会出现竞争情况，如在其它地方修改 Infromer GetStore 和 GetIndexer 方法返回的缓存。

另外，一般自定义 controller 的模式是：
1. 创建一个 SharedIndexInformer 和 workerqueue。
2. 在 SharedIndexInformer 中注册 OnAdd/OnUpdate/OnDelete 的处理函数是 enqueue，它向队列压入对象的 Key。
3. 运行几个 worker，分别从 workerqueue 中 Pop 对象 Key，从 Key 提取 namespace 和 objname；
4. 再调用从 SharedIndexInformer 获取的对象 Lister，根据 namespace 和 objname 获取对象；

这种模式的情况下，如果快速的 Add 再 Delete 对象，则 worker 用 Add 事件的对象 key 查找缓存，可能出现**找不到**的情况。

对于 CRD 对象的删除事件，一般是**不需**要定义处理函数（如 enqueue 或自定义函数），因为删除意味着该对象已经不在 K8S 中了。但是如果需要清理该 CRD 创建的 K8S 资源对象，则可能需要为 CRD 对象的 OnDelete 事件绑定处理函数，或者使用 finalized 机制。

如何快速查找 CRD 创建的 K8S 资源对象呢？简单的办法是给它创建的对象打上**包含 CRD 对象名的标签**。另外  CRD 对象名最好是随机的，否则删除和创建同一个 CRD 对象的资源时可能出现**竞争**关系。

对于 CRD 创建的类型对象，获取到后，需要看它是否是 CRD 创建的，如果不是则需要忽略。另外，对这些对象的删除事件，需要捕获，一般需要再次创建该对象。

##

Controller 实际是被 NewInformer 和 NewIndexerInformer 返回的，它本身没有 New 等创建函数。

``` go
type Config struct {
    // 缓存 ObjectType 类型对象的队列，同时也被 Reflector 使用。
    // 后续 NewInformer、NewIndexerInformer 创建该配置时，实际创建的是 DeltaFIFO 类型的 Queue。
	Queue

    // Controller 为 ObjectType 创建 Reflector 使用的 ListerWatcher;
	ListerWatcher

    // 对于对象的每个事件，调用该处理函数
	Process ProcessFunc

    // 该 Controller 关注和管理的对象类型
	ObjectType runtime.Object

	FullResyncPeriod time.Duration
	ShouldResync ShouldResyncFunc
	RetryOnError bool
}

// controller 是 Controller 的实现，但是没有创建它的 New 方法
// 所以 controller 实际是由 NewInformer、NewIndexerInformer 来创建和使用的
type controller struct {
	config         Config
	reflector      *Reflector
	reflectorMutex sync.RWMutex
	clock          clock.Clock
}

func (c *controller) Run(stopCh <-chan struct{}) {
	defer utilruntime.HandleCrash()
	go func() {
		<-stopCh
        // controller 运行结束时关闭队列
		c.config.Queue.Close()
	}()

    // 根据 Controller 的配置，初始化监控 ObjectType 类型对象的 Reflector
    // 初始化 Refector 时，传入了 Controller 的 Queue(DeltaFIFO)，所以 Refector 会同步更新该 Queue；
	r := NewReflector(
		c.config.ListerWatcher,
		c.config.ObjectType,
		c.config.Queue,
		c.config.FullResyncPeriod,
	)
	r.ShouldResync = c.config.ShouldResync
	r.clock = c.clock

	c.reflectorMutex.Lock()
	c.reflector = r
	c.reflectorMutex.Unlock()

	var wg wait.Group
	defer wg.Wait()

    // 在另一个 goroutine 里启动 Reflector
	wg.StartWithChannel(stopCh, r.Run)

    // 阻塞执行 c.processLoop，该 Loop 是个死循环，只是在出错时才返回值，这是 sleep 1s 后重新执行
	wait.Until(c.processLoop, time.Second, stopCh)
}

// Refector 将对象的 Deltas 事件更新到 controller 的 Queue
// 这个循环是一直从 Queue 中 Pop 最开始的 Deltas，然后传给 Controller 配置的处理器（c.config.Process）
// 如果处理器处理事件失败，且 Controller 配置了 RetryOnError 参数，则将 Deltas 重新放回 Queue；
func (c *controller) processLoop() {
	for {
		obj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))
		if err != nil {
			if err == FIFOClosedError {
				return
			}
			if c.config.RetryOnError {
				// This is the safe way to re-enqueue.
				c.config.Queue.AddIfNotPresent(obj)
			}
		}
	}
}



func NewInformer(
	lw ListerWatcher,
	objType runtime.Object,
	resyncPeriod time.Duration,
	h ResourceEventHandler,
) (Store, Controller) {
    // Store 是一个存储对象的内存数据库，它使用 KeyFunc 函数获取对象的唯一访问 key。
    // NewStore 实际返回的是一个 ThreadSafe 类型
	clientState := NewStore(DeletionHandlingMetaNamespaceKeyFunc)

	// This will hold incoming changes. Note how we pass clientState in as a
	// KeyLister, that way resync operations will result in the correct set
	// of update/delete deltas.
	fifo := NewDeltaFIFO(MetaNamespaceKeyFunc, clientState)

	cfg := &Config{
		Queue:            fifo,
		ListerWatcher:    lw,
		ObjectType:       objType,
		FullResyncPeriod: resyncPeriod,
		RetryOnError:     false,

		Process: func(obj interface{}) error {
			// from oldest to newest
			for _, d := range obj.(Deltas) {
				switch d.Type {
				case Sync, Added, Updated:
					if old, exists, err := clientState.Get(d.Object); err == nil && exists {
						if err := clientState.Update(d.Object); err != nil {
							return err
						}
						h.OnUpdate(old, d.Object)
					} else {
						if err := clientState.Add(d.Object); err != nil {
							return err
						}
						h.OnAdd(d.Object)
					}
				case Deleted:
					if err := clientState.Delete(d.Object); err != nil {
						return err
					}
					h.OnDelete(d.Object)
				}
			}
			return nil
		},
	}
	return clientState, New(cfg)
}
```